#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <iostream>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <linux/dma-heap.h>
#include "../../common_include/inc/rk_mpi.h"
#include "../../common_include/rga/RgaUtils.h"
#include "../../common_include/rga/im2d.h"
#include "../../common_include/rga/rga.h"
// #include "mpp_log.h"

#define PACKET_SIZE 32768

#define WIDTH 1920
#define HEIGHT 1080

int main(int argc, char **argv) {
    if (argc < 2) {
        printf("Usage: %s input.h264\n", argv[0]);
        return -1;
    }

    const char *filename = argv[1];
    FILE *fp = fopen(filename, "rb");
    if (!fp) {
        perror("fopen");
        return -1;
    }

    MppCtx ctx;
    MppApi *mpi;
    

    // Создаём контекст
    if (mpp_create(&ctx, &mpi)) {
        printf("mpp_create failed\n");
        return -1;
    }
    int param = 1;
    mpi->control(ctx, MPP_DEC_SET_PARSER_SPLIT_MODE, &param);
    // Инициализация декодера для H.264
    if (mpp_init(ctx, MPP_CTX_DEC, MPP_VIDEO_CodingAVC)) {
        printf("mpp_init failed\n");
        return -1;
    }

    // Буфер для чтения пакетов H.264
    MppBufferGroup group = NULL;
    
    mpp_buffer_group_get_external(&group, MPP_BUFFER_TYPE_DMA_HEAP);

    


    

    

    int fd = open("/dev/dma_heap/system", O_RDWR);
    for (int i = 0; i < 20; i++) {

        struct dma_heap_allocation_data req = {
        .len = WIDTH*HEIGHT * 3 / 2,
        .fd_flags = O_RDWR | O_CLOEXEC,
        .heap_flags = 0,
        };
        ioctl(fd, DMA_HEAP_IOCTL_ALLOC, &req);

        int dma_fd = req.fd;

        MppBuffer buffer;
        MppBufferInfo info;
        memset(&info, 0, sizeof(info));
        info.type = MPP_BUFFER_TYPE_DMA_HEAP;
        info.size = WIDTH*HEIGHT* 3 / 2;
        info.fd = dma_fd;
        info.index = i;

        mpp_buffer_import(&buffer, &info);
        mpp_buffer_commit(group, &info);
    }
    
    unsigned char *buf = (unsigned char *)malloc(PACKET_SIZE);
    while (!feof(fp)) {

        int read_size = fread(buf, 1, PACKET_SIZE, fp);

        if (read_size <= 0) {
            break;
        }

        MppPacket packet = NULL;
        mpp_packet_init(&packet, buf, PACKET_SIZE);
        mpp_packet_set_pos(packet, buf);
        mpp_packet_set_length(packet, read_size);
        try_again:
        MPP_RET ret = mpi->decode_put_packet(ctx, packet);

        // if (ret != 0) {
        //     std::cout << "decode put packet error: " << ret << std::endl;
        // }

        if (ret == MPP_ERR_BUFFER_FULL) {
            // вычистить очередь кадров
            while (1) {
                MppFrame frm = NULL;
                MPP_RET r2 = mpi->decode_get_frame(ctx, &frm);
                if (r2 || !frm)
                    break;
                // обработать/освободить
                mpp_frame_deinit(&frm);
            }
            usleep(1000);
            goto try_again;
        }
        
        mpp_packet_deinit(&packet); 

        while (1) {
            MppFrame frame = NULL;
            ret = mpi->decode_get_frame(ctx, &frame);
            if (ret != MPP_OK) {
                std::cout << "ret != ok: " << ret << std::endl;
                break;
            }
            if (!frame) {
               // std::cout << "frame == 0" << std::endl;
                break;
            } else {
                std::cout << "frame exists" << std::endl;
            }

            mpi->control(ctx, MPP_DEC_SET_EXT_BUF_GROUP, group);

            if (mpp_frame_get_info_change(frame)) {
                // тут обычно вызывают MPP_DEC_SET_INFO_CHANGE_READY
                mpi->control(ctx, MPP_DEC_SET_INFO_CHANGE_READY, NULL);
                mpp_frame_deinit(&frame);
                continue;
            }

            if (!mpp_frame_get_errinfo(frame)) {
                MppBuffer frm_buf = mpp_frame_get_buffer(frame);
                int w  = mpp_frame_get_width(frame);
                int h  = mpp_frame_get_height(frame);
                int fd = mpp_buffer_get_fd(frm_buf);

                // вот этот fd ты и отдаёшь в RGA (wrapbuffer_fd)
            }

            mpp_frame_deinit(&frame);
        }


    }


    return 0;
}
